Eigen::SparseMatrix<double> sparse(_mesh->cells()->size(), _mesh->cells()->size());
    Eigen::VectorXd column;
    column.resize(_mesh->cells()->size());
    column.setZero();
    std::vector<Eigen::Triplet<double>> coefs;
    
    
    for (size_t i = 0; i < _mesh->cells()->size(); i++)
    {
        auto cell = _mesh->cells()->at(i).get();
        vector2d pos1 = cell->getCentroid();
        column(i) = 0;
        double C = 1000; //_fluidMaterial->conductivity(_fields->scalarFields()->at(i)) / (_fluidMaterial->specificHeat(_fields->scalarFields()->at(i)) * _fluidMaterial->density(_fields->scalarFields()->at(i)));
        for (auto face : cell->faces())
        {
            if (face->isBoundary())
            {
                /*vector2d pos2 = face->getCentroid();
                double modulo = (pos2 - pos1).norm();
                vector2d gradient = (pos2 - pos1) / pow(modulo, 2);
                double coef1 = C * face->area() * gradient.dot(face->getNormal(cell)) - 1;
                coefs.push_back(Eigen::Triplet<double>(i, i, coef1));

                double temp = 300+rand()*1000.0/(double)RAND_MAX;
                double flujo = 0;
                //column(i) += (temp * coef1);
                column(i) += (flujo);*/
                auto bc = bc::ConstantTemperature(300);
                auto bc_coef = bc.getBCCoef(cell, face);
                
                for (auto coef : bc_coef.first)
                {
                    coefs.push_back(coef);
                }
                column(i) += bc_coef.second;   

            }
            else
            {
                
                auto other_cell = face->getOtherCell(cell);
                vector2d pos2 = other_cell->getCentroid();
                double modulo = (pos2 - pos1).norm();
                vector2d gradient = (pos2 - pos1) / pow(modulo, 2);
                
                double coef1 = C * face->area() * gradient.dot(face->getNormal(cell));
                double coef2 = -coef1;
                coefs.push_back(Eigen::Triplet<double>(i, i, coef1));
                coefs.push_back(Eigen::Triplet<double>( i, other_cell->index(), coef2));
            }

        }
    }

    sparse.setFromTriplets(coefs.begin(), coefs.end(), [](double phi1, double phi2) {
        return phi1 + phi2;
});
    Eigen::SimplicialCholesky < Eigen::SparseMatrix<double> > chol(sparse);
    // realiza una factorizaci√≥n de Cholesky de A

    Eigen::VectorXd x = chol.solve(column);
    //std::cout << sparse << std::endl;
    //std::cout << column << std::endl;
    //std::cout << x << std::endl;

    //Export solution
    // X[m] Y[m] value[K]
    std::ofstream file;
    file.open("Result.txt", std::ios::trunc);
    if (file.is_open())
    {
        file << "X" << "," << "Y" << "," << "Value" << std::endl;
        for (int i = 0; i < x.size(); i++)
        {
            
            vector2d pos = _mesh->cells()->at(i)->getCentroid();
            file << pos.x() << "," << pos.y() << "," << x(i) << std::endl;
        }
        file.close();
    }